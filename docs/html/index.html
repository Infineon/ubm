<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UBM Middleware</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UBM Middleware</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">UBM Middleware Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="section_mainpage_overview"></a>
Overview</h1>
<p>The UBM middleware provides the implementation of the Universal Backplane Management (UBM) - a common backplane management framework for a host, to determine the SAS/SATA/PCIe backplane capabilities, Drive Facing Connector (DFC) Status, and Control information, and to read the port routing of the Drive Facing Connectors to Host Facing Connectors (HFC) of the backplane.</p>
<p><b>Features:</b></p><ul>
<li>Status and Control over Drive Facing Connector I/O</li>
<li>High speed lane port routing assignments to Host Facing Connectors</li>
<li>Backplane capabilities including:<ul>
<li>PCIe Reference Clock expectations</li>
<li>PCIe Reset expectations</li>
<li>Power Disable support</li>
<li>Dual Port support</li>
</ul>
</li>
<li>Controller programmable firmware update</li>
</ul>
<h1><a class="anchor" id="section_ubm_general"></a>
General Description</h1>
<p>Include mtb_ubm.h to get access to all the functions and other declarations in this middleware.</p>
<p>See the <a class="el" href="index.html#subsection_ubm_bootloader">Basic UBM application with Update mode</a> to start with the bootloader application and the <a class="el" href="index.html#subsection_ubm_main">UBM Controller Application</a> for the main application.</p>
<p>Refer to the <a href="https://members.snia.org/document/dl/27167"><b>SFF-TA-1005</b></a> for the UBM specification. Refer to the release notes for limitations and compatibility information.</p>
<h2><a class="anchor" id="subsection_ubm_pcie_reset_clock_routing"></a>
The control of the PCIe reset and clock routing</h2>
<p>The PCIe reset signal is controlled directly by the UBM controller. The PCIe RefClk signal is driven by a specific chip. (e.g., <a href="https://www.renesas.com/tw/en/document/dst/9db403d-datasheet?r=73671">https://www.renesas.com/tw/en/document/dst/9db403d-datasheet?r=73671</a>). For more details, refer to the backplane schematic. The UBM Middleware simply provides the control signal for the specific multiplexer. The pins for the above signals are assigned via the configuration structure.</p>
<h2><a class="anchor" id="subsection_ubm_firmare_upload_host_tool"></a>
The requirements to Firmware Host Tool.</h2>
<dl class="section note"><dt>Note</dt><dd>The UBM Middleware does not provide any Firmware Host Tool. This is a vendor-specific application to be implemented by the vendor side.</dd></dl>
<p>As described later, the UBM middleware provides a transport layer for downloading a new firmware image. The Host update tool (software tool) is used for transfer. This instrument must meet the following requirements:</p><ol type="1">
<li>The Host tool supports the 2WIRE interface for communication with the UBM controller.</li>
<li>The update process complies with the procedure described in SFF-TA-1005 Rev 1.4, section 5.21.</li>
<li>The Host tool calculates the flash memory parameters based on the data received by the "Get Non-Volatile Storage Geometry Subcommand".</li>
<li>The Host tool can parse binary, hexadecimal files into packets for transmission. According to the UBM specification, the Host transmits sector indexes (flash memory lines) that can exceed the maximum length of the UBM command. Sector indexes are divided into packets. For more details, see the "Program Subcommand" description.</li>
<li>To record data in flash memory, pauses of 30 and 16 milliseconds are set for "Program Subcommand" and "Erase Subcommand" respectively. For more details on the time parameters of operations with flash memory, see the manual for the target device. <dl class="section note"><dt>Note</dt><dd>A pause for "Program Subcommand" is necessary only after the last data packet is received and the index sector is completely formed.</dd></dl>
</li>
<li>The UBM specification contains "Verify Image Subcommand" but it does not define the verification method. A checksum check of the entire application, including additional areas of the MCUBoot bootloader, is applied in the middleware. The Host tool calculates the checksum of the binary file previously signed by MCUBoot. Write the calculated CRC bytes at address BASE ADDRESS + 0x200. The CRC endianness must be little. The following is the function for calculating the checksum on Python: <div class="fragment"><div class="line"><span class="comment"># calculate_checksum: Calculate checksum CRC32 algorithm.</span></div><div class="line"><span class="comment"># parameters:</span></div><div class="line"><span class="comment"># ih - (input hex) This is the array of the binary data of the</span></div><div class="line"><span class="comment">#       image.</span></div><div class="line"><span class="comment"># len - length of the image.</span></div><div class="line"><span class="keyword">def </span>calculate_checksum(ih, len):</div><div class="line">    i = 1</div><div class="line">    crc = 0xFFFFFFFF</div><div class="line"></div><div class="line">    crcTable =\</div><div class="line">    [</div><div class="line">        0x00000000, 0x105ec76f, 0x20bd8ede, 0x30e349b1,</div><div class="line">        0x417b1dbc, 0x5125dad3, 0x61c69362, 0x7198540d,</div><div class="line">        0x82f63b78, 0x92a8fc17, 0xa24bb5a6, 0xb21572c9,</div><div class="line">        0xc38d26c4, 0xd3d3e1ab, 0xe330a81a, 0xf36e6f75,</div><div class="line">    ]</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len):</div><div class="line">        crc = crc ^ ih[i]</div><div class="line">        crc = (crc &gt;&gt; 4) ^ crcTable[crc &amp; 0xF]</div><div class="line">        crc = (crc &gt;&gt; 4) ^ crcTable[crc &amp; 0xF]</div><div class="line">    crc = ~crc</div><div class="line">    <span class="keywordflow">return</span> crc &amp; 0xffffffff</div></div><!-- fragment --></li>
</ol>
<h1><a class="anchor" id="section_ubm_quick_start"></a>
Quick Start Guide</h1>
<h2><a class="anchor" id="subsection_ubm_bootloader"></a>
Basic UBM application with Update mode</h2>
<p>The UBM Middleware supports Update mode. This feature is based on the MCUBoot bootloader, and the transport layer, which provides the UBM Middleware for transferring a new application image to the slot. </p><dl class="section note"><dt>Note</dt><dd>Strongly recommended - learn more about MCUBoot and multi-application projects from the following sources:<ol type="1">
<li><a href="https://github.com/mcu-tools/mcuboot/tree/main/docs">MCUBoot documentation</a></li>
<li><a href="https://github.com/mcu-tools/mcuboot/tree/cypress/boot/cypress/MCUBootApp">MCUBoot/Infineon</a></li>
<li><a href="https://github.com/Infineon/mtb-example-psoc6-mcuboot-basic">MCUBoot basic application</a></li>
<li><a href="https://documentation.infineon.com/html/psoc6/yvt1667482437523.html">Dual application guide</a></li>
</ol>
</dd></dl>
<p>Use this <a href="https://github.com/Infineon/cce-mtb-psoc61-mcuboot-bootloader">guide</a> to create two applications:</p><ul>
<li>The bootloader - a program that checks the slots in the flash memory and downloads a new firmware image when it finds one.</li>
<li>The blinky application - the user's main application that will be updated to run the UBM Middleware.</li>
</ul>
<p>After creating a sample project:</p><ul>
<li>Apply the modifications described later in this section to update the "bootloader" and "blinky" application.</li>
<li>Update the main.c file of the "blinky" application with the alterations outlined in the following section <a class="el" href="index.html#subsection_ubm_main">UBM Controller Application</a>.</li>
</ul>
<ol type="1">
<li>Include the UBM middleware into the project using the ModusToolbox&trade; Library Manager.</li>
<li>Copy the configuration file from <em> mtb_shared/ubm/release[version]/ubm_flash_map/[config].json </em> to the Bootloader application <em>"flashmap"</em> folder.</li>
<li>Update the FLASH_MAP variable in <em>"shared_config.mk"</em> to the previously copied JSON file <div class="fragment"><div class="line"><span class="preprocessor"># Flashmap JSON file name</span></div><div class="line"><span class="preprocessor">FLASH_MAP=psoc62_swap_single_custom.json</span></div></div><!-- fragment --></li>
<li>Update the configurational defines in the configurational file in <em></em>[app_name]/blinky/imports/ubm/mtb_ubm_config.h: <dl class="section note"><dt>Note</dt><dd>The configurational file mtb_ubm_config.h is added to the Blinky application in the folder "imports" after the UBM middleware is added using the Library Manager and the following values are auto-updated: <div class="fragment"><div class="line"><span class="preprocessor">#define MTB_UBM_UPGRADE_AREA_START_ADDRESS (0x10018000U) </span></div></div><!-- fragment --> <div class="fragment"><div class="line"><span class="preprocessor">#define MTB_UBM_UPGRADE_AREA_SIZE          (0x20000U) </span></div></div><!-- fragment --> Update these addresses when the JSON configuration file is changed.</dd></dl>
</li>
<li>Update the main makefile of the Blinky application - modify the rule for the post-build processing: <div class="fragment"><div class="line">POSTBUILD=\</div><div class="line">cp -f $(BINARY_OUT_PATH).hex $(BINARY_OUT_PATH)_raw.hex;\</div><div class="line">rm -f $(BINARY_OUT_PATH).hex;\</div><div class="line">$(CY_ELF_TO_HEX_TOOL) --change-addresses=$(HEADER_OFFSET) --<span class="keyword">remove</span>-section .cy_em_eeprom $(CY_ELF_TO_HEX_OPTIONS) $(BINARY_OUT_PATH).elf $(BINARY_OUT_PATH)_unsigned.hex;\</div><div class="line">$(PYTHON_PATH) $(IMGTOOL_PATH) $(SIGN_ARGS) $(BINARY_OUT_PATH)_unsigned.hex $(BINARY_OUT_PATH).hex;</div></div><!-- fragment --> <dl class="section warning"><dt>Warning</dt><dd>Delete the cy_em_eeprom section because it can break the signing process. </dd>
<dd>
Known issue: The main Makefile of Blinky application has one incorrect path. Change this path: <div class="fragment"><div class="line">ALL_FILES=*</div><div class="line"><span class="preprocessor"># Correct path:</span></div><div class="line">SOURCES+=$(wildcard $(SEARCH_mcuboot)/boot/bootutil/src/$(ALL_FILES).c)\</div><div class="line">         $(wildcard $(MCUBOOT_CY_PATH)/libs/watchdog/$(ALL_FILES).c)\</div><div class="line">         $(wildcard $(MCUBOOT_CY_PATH)/platforms/img_confirm/$(FAMILY)/$(ALL_FILES).c)</div></div><!-- fragment --></dd></dl>
</li>
<li>Update the <em>main.c</em> file in the Blinky application as described in <a class="el" href="index.html#subsection_ubm_main">UBM Controller Application</a>. </li>
</ol>
<h2><a class="anchor" id="subsection_ubm_main"></a>
UBM Controller Application</h2>
<ol type="1">
<li>When the UBM middleware is added to the project, the configurational file <em>mtb_ubm_config.h</em> is added to the Blinky application to the <em>"imports"</em> folder. This file contains the main configurational defines, e.g. the number of the HFCs or the number of DFCs, etc. Update the necessary parameters according to your backplane configuration. An example for 2 HFCs, 2 DFCs, and 2 Routes: <div class="fragment"><div class="line"><span class="preprocessor">#define MTB_UBM_HFC_MAX_NUM       (8U)      </span><span class="comment">/* The maximum number of the HFCs in the backplane */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">#define MTB_UBM_DFC_MAX_NUM       (8U)      </span><span class="comment">/* The maximum number of the DFCs in the backplane */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">#define MTB_UBM_ROUTES_MAX_NUM    (32U)     </span><span class="comment">/* The maximum number of the routes in the backplane */</span><span class="preprocessor"></span></div></div><!-- fragment --></li>
<li>Include the UBM middleware header file in your <em>main.c</em> file: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mtb_ubm.h&quot;</span></div></div><!-- fragment --></li>
<li>Add the <a class="el" href="group__group__ubm__functions.html#ga8f6b9404cb8cc59d8479c976df0aa4c4" title="Initializes the UBM middleware. ">mtb_ubm_init()</a> function call in your <em>main.c</em> file, for example: <div class="fragment"><div class="line"><a class="code" href="group__group__ubm__enums.html#ga7edd9650e9144861643adbf7aefbcc48">mtb_en_ubm_status_t</a> sts = <a class="code" href="group__group__ubm__functions.html#ga8f6b9404cb8cc59d8479c976df0aa4c4">mtb_ubm_init</a>(&amp;ubm_backplane_configuration, &amp;ubm_backplane_control_signals, &amp;ubm_context);</div></div><!-- fragment --></li>
<li>The following parameters are required for the <a class="el" href="group__group__ubm__functions.html#ga8f6b9404cb8cc59d8479c976df0aa4c4" title="Initializes the UBM middleware. ">mtb_ubm_init()</a> function: <div class="fragment"><div class="line"><a class="code" href="structmtb__stc__ubm__backplane__cfg__t.html">mtb_stc_ubm_backplane_cfg_t</a> ubm_backplane_configuration;</div><div class="line"><a class="code" href="structmtb__stc__ubm__backplane__control__signals__t.html">mtb_stc_ubm_backplane_control_signals_t</a> ubm_backplane_control_signals;</div><div class="line"><a class="code" href="structmtb__stc__ubm__context__t.html">mtb_stc_ubm_context_t</a> ubm_context;</div></div><!-- fragment --></li>
<li>The first parameter <a class="el" href="structmtb__stc__ubm__backplane__cfg__t.html" title="UBM backplane configuration structure. ">mtb_stc_ubm_backplane_cfg_t</a> contains the configurational values required to set up the UBM middleware, for example: <div class="fragment"><div class="line"><a class="code" href="structmtb__stc__ubm__backplane__cfg__t.html">mtb_stc_ubm_backplane_cfg_t</a> ubm_backplane_configuration =</div><div class="line">{</div><div class="line">    .<a class="code" href="structmtb__stc__ubm__backplane__cfg__t.html#a647dbfd6df2c7a5a4cf6e95b88ce63fc">num_of_hfc</a> = 4U,                       <span class="comment">/* Number of the HFCs in the backplane */</span></div><div class="line">    .num_of_dfc = 4U,                       <span class="comment">/* Number of the DFCs in the backplane */</span></div><div class="line">    .num_of_routes = 4U,                    <span class="comment">/* Number of the routes in the backplane */</span></div><div class="line">    .starting_slot = 0x00U,                 <span class="comment">/* UBM starting slot */</span></div><div class="line">    .overview_area = &amp;overview_area,        <span class="comment">/* Overview area configuration */</span></div><div class="line">    .fru_config = &amp;eepromConfig,            <span class="comment">/* Storage configuration for the FRU */</span></div><div class="line">    .ses_event_handler = NULL,              <span class="comment">/* APP handler for the SES Array Device Slot Control Element */</span></div><div class="line">    .bifurcate_port = <span class="keyword">false</span>,                <span class="comment">/* Indicates if the DFC port link width shall be bifurcated */</span></div><div class="line">    .silicon_identity =</div><div class="line">    {</div><div class="line">        .pcie_vendor_id = 0xaa55U,          <span class="comment">/* PCIe Vendor ID */</span></div><div class="line">        .device_code = 0xface8d00U,         <span class="comment">/* UBM Controller Device code */</span></div><div class="line">        .fw_version_minor = 0x12U,          <span class="comment">/* UBM Controller Image Version Minor */</span></div><div class="line">        .fw_version_major = 0x21U,          <span class="comment">/* UBM Controller Image Version Minor */</span></div><div class="line">        .vendor_specific = 0x1234U,         <span class="comment">/* UBM Controller vendor-specific data */</span></div><div class="line">    },</div><div class="line">    .backplane_info =</div><div class="line">    {</div><div class="line">        .backplane_type = 0x05U,            <span class="comment">/* Backplane type */</span></div><div class="line">        .backplane_number = 0x0AU,          <span class="comment">/* Backplane number */</span></div><div class="line">    },</div><div class="line">    .capabilities =</div><div class="line">    {</div><div class="line">        .clock_routing = <span class="keyword">true</span>,              <span class="comment">/* Indicates availability of high speed differential clock routing (i.e., RefClk)</span></div><div class="line"><span class="comment">                                               from the Host Facing Connector to the Drive Facing Connector */</span></div><div class="line">        .slot_power_control = <span class="keyword">true</span>,         <span class="comment">/* Indicates if the Drive Facing Connectors support Power Disable (i.e., PwrDIS signal) */</span></div><div class="line">        .pcie_reset_control = <span class="keyword">true</span>,         <span class="comment">/* Indicates if PCIe Reset Control is supported */</span></div><div class="line">        .dual_port = <span class="keyword">true</span>,                  <span class="comment">/* Indicates if Dual Port DFC connectors are routed */</span></div><div class="line">        .i2c_reset_operation = MTB_UBM_CAP_2WIRE_RESET_OP_FRU_CONTROLLER, <span class="comment">/* Indicates the 2WIRE_RESET# signal support */</span></div><div class="line">        .change_detect_interrupt = <span class="keyword">true</span>,    <span class="comment">/* Indicates if the CHANGE_DETECT# signal interrupt operation is supported */</span></div><div class="line">        .dfc_change_count_supported = <span class="keyword">true</span>, <span class="comment">/* Indicates if the change count is maintained per individual DFC Status and Control Command Descriptor */</span></div><div class="line">        .prsnt_reported = <span class="keyword">true</span>,             <span class="comment">/* Indicates if the PRSNT# signal is reported */</span></div><div class="line">        .ifdet_reported = <span class="keyword">true</span>,             <span class="comment">/* Indicates if the IFDET# signal is reported */</span></div><div class="line">        .ifdet2_reported = <span class="keyword">true</span>,            <span class="comment">/* Indicates if the IFDET2# signal is reported */</span></div><div class="line">        .perst_override_supported = <span class="keyword">true</span>,   <span class="comment">/* Indicates if the UBM Controller supports the DFC</span></div><div class="line"><span class="comment">                                               PERST# Management Override field in the Features Command */</span></div><div class="line">        .smb_reset_supported = <span class="keyword">true</span>,        <span class="comment">/* Indicates if the UBM Controller supports control over the DFC</span></div><div class="line"><span class="comment">                                               SMBRST# signals (e.g. See SFF-TA-1009) for all DFCs managed by the HFC */</span></div><div class="line">    },</div><div class="line">    .route_information =</div><div class="line">    {</div><div class="line">        {</div><div class="line">            .ubm_ctrl_type = <a class="code" href="group__group__ubm__enums.html#gga0576582dae1a6af815a804705ab38ae3a3bfeff764d23f5a8619f0776a5d5afeb">MTB_UBM_CONTROLLER_SPEC_DEFINED</a>,   <span class="comment">/* UBM controller type */</span></div><div class="line">            .ubm_ctrl_slave_addr = 0x13U,                       <span class="comment">/* UBM Controller 2Wire slave address */</span></div><div class="line">            .drive_connector_idx = 0x0U,                        <span class="comment">/* Indicates the DFC identity */</span></div><div class="line">            .drive_types_supported =                            <span class="comment">/* Indicates which drive types are supported in the DFC */</span></div><div class="line">            {</div><div class="line">                .sff_ta_1001 = <span class="keyword">true</span>,                            <span class="comment">/* SFF-TA-1001 PCIe */</span></div><div class="line">                .gen_z = <span class="keyword">false</span>,                                 <span class="comment">/* Gen-Z */</span></div><div class="line">                .sas_sata = <span class="keyword">true</span>,                               <span class="comment">/* SAS/SATA */</span></div><div class="line">                .quad_pcie = <span class="keyword">true</span>,                              <span class="comment">/* Quad PCIe */</span></div><div class="line">                .dfc_empty = <span class="keyword">true</span>,                              <span class="comment">/* DFC Empty */</span></div><div class="line">            },</div><div class="line">            .drive_link_width = <a class="code" href="group__group__ubm__enums.html#gga25b72ac193b03b7c8a3de9ed81668d21af40a4f7c8eb47f641e62d8d79e6124b2">MTB_UBM_LINK_WIDTH_X4</a>,          <span class="comment">/* Indicates the number of lanes in the port */</span></div><div class="line">            .port_type = <a class="code" href="group__group__ubm__enums.html#gga8523481e3974ed225ea2059ca5cce4a2a6b4e585160698893beaadfc55582446a">MTB_UBM_PORT_TYPE_SEGREGATED</a>,          <span class="comment">/* Indicates the connector port type which is routed from the DFC to the HFC */</span></div><div class="line">            .domain = <a class="code" href="group__group__ubm__enums.html#gga6c9a9506e1cbf8b17449a4f4bbdc1b8aa25db6cce4bc81d5427d4f95820516dbf">MTB_UBM_PORT_DOMAIN_PRIMARY</a>,              <span class="comment">/* Indicates if this route is describing the primary or secondary port of a DFC */</span></div><div class="line">            .max_sata_line_rate = <a class="code" href="group__group__ubm__enums.html#ggab1ec1458778a706bd254c5a718a13d28a9c26126bb4ce328dba127c0762f45c92">MTB_UBM_SATA_NO_RATE_LIMIT</a>,   <span class="comment">/* Max SATA Link Rate */</span></div><div class="line">            .max_pcie_line_rate = <a class="code" href="group__group__ubm__enums.html#ggad83b93024e86bfe947a1ddef18eb1f0fa6b3eaab5d64ccc50b221d228f88eef0f">MTB_UBM_PCIE_NO_RATE_LIMIT</a>,   <span class="comment">/* Max PCIe Link Rate */</span></div><div class="line">            .max_sas_line_rate = <a class="code" href="group__group__ubm__enums.html#gga7848037c7789e6e85875078254df1daaac0cf331675e14b6d4f86067a2e75b746">MTB_UBM_SAS_NO_RATE_LIMIT</a>,     <span class="comment">/* Max SAS Link Rate */</span></div><div class="line">            .hfc_starting_phy_lane = 0x0U,                      <span class="comment">/* Indicates the HFC starting lane */</span></div><div class="line">            .hfc_identifier = 0x0U,                             <span class="comment">/* Indicates the HFC identity */</span></div><div class="line">            .slot_offset = 0x00U,                               <span class="comment">/* Indicates the backplane slot offset for the DFC */</span></div><div class="line">        },</div><div class="line">        {</div><div class="line">            .ubm_ctrl_type = <a class="code" href="group__group__ubm__enums.html#gga0576582dae1a6af815a804705ab38ae3a3bfeff764d23f5a8619f0776a5d5afeb">MTB_UBM_CONTROLLER_SPEC_DEFINED</a>,   <span class="comment">/* UBM controller type */</span></div><div class="line">            .ubm_ctrl_slave_addr = 0x13U,                       <span class="comment">/* UBM Controller 2Wire slave address */</span></div><div class="line">            .drive_connector_idx = 0x1U,                        <span class="comment">/* Indicates the DFC identity */</span></div><div class="line">            .drive_types_supported =                            <span class="comment">/* Indicates which drive types are supported in the DFC */</span></div><div class="line">            {</div><div class="line">                .sff_ta_1001 = <span class="keyword">true</span>,                            <span class="comment">/* SFF-TA-1001 PCIe */</span></div><div class="line">                .gen_z = <span class="keyword">false</span>,                                 <span class="comment">/* Gen-Z */</span></div><div class="line">                .sas_sata = <span class="keyword">true</span>,                               <span class="comment">/* SAS/SATA */</span></div><div class="line">                .quad_pcie = <span class="keyword">true</span>,                              <span class="comment">/* Quad PCIe */</span></div><div class="line">                .dfc_empty = <span class="keyword">true</span>,                              <span class="comment">/* DFC Empty */</span></div><div class="line">            },</div><div class="line">            .drive_link_width = <a class="code" href="group__group__ubm__enums.html#gga25b72ac193b03b7c8a3de9ed81668d21af40a4f7c8eb47f641e62d8d79e6124b2">MTB_UBM_LINK_WIDTH_X4</a>,          <span class="comment">/* Indicates the number of lanes in the port */</span></div><div class="line">            .port_type = <a class="code" href="group__group__ubm__enums.html#gga8523481e3974ed225ea2059ca5cce4a2a6b4e585160698893beaadfc55582446a">MTB_UBM_PORT_TYPE_SEGREGATED</a>,          <span class="comment">/* Indicates the connector port type which is routed from the DFC to the HFC */</span></div><div class="line">            .domain = <a class="code" href="group__group__ubm__enums.html#gga6c9a9506e1cbf8b17449a4f4bbdc1b8aa25db6cce4bc81d5427d4f95820516dbf">MTB_UBM_PORT_DOMAIN_PRIMARY</a>,              <span class="comment">/* Indicates if this route is describing the primary or secondary port of a DFC */</span></div><div class="line">            .max_sata_line_rate = <a class="code" href="group__group__ubm__enums.html#ggab1ec1458778a706bd254c5a718a13d28a9c26126bb4ce328dba127c0762f45c92">MTB_UBM_SATA_NO_RATE_LIMIT</a>,   <span class="comment">/* Max SATA Link Rate */</span></div><div class="line">            .max_pcie_line_rate = <a class="code" href="group__group__ubm__enums.html#ggad83b93024e86bfe947a1ddef18eb1f0fa6b3eaab5d64ccc50b221d228f88eef0f">MTB_UBM_PCIE_NO_RATE_LIMIT</a>,   <span class="comment">/* Max PCIe Link Rate */</span></div><div class="line">            .max_sas_line_rate = <a class="code" href="group__group__ubm__enums.html#gga7848037c7789e6e85875078254df1daaac0cf331675e14b6d4f86067a2e75b746">MTB_UBM_SAS_NO_RATE_LIMIT</a>,     <span class="comment">/* Max SAS Link Rate */</span></div><div class="line">            .hfc_starting_phy_lane = 0x0U,                      <span class="comment">/* Indicates the HFC starting lane */</span></div><div class="line">            .hfc_identifier = 0x1U,                             <span class="comment">/* Indicates the HFC identity */</span></div><div class="line">            .slot_offset = 0x01U,                               <span class="comment">/* Indicates the backplane slot offset for the DFC */</span></div><div class="line">        },</div><div class="line">        {</div><div class="line">            .ubm_ctrl_type = <a class="code" href="group__group__ubm__enums.html#gga0576582dae1a6af815a804705ab38ae3a3bfeff764d23f5a8619f0776a5d5afeb">MTB_UBM_CONTROLLER_SPEC_DEFINED</a>,   <span class="comment">/* UBM controller type */</span></div><div class="line">            .ubm_ctrl_slave_addr = 0x4DU,                       <span class="comment">/* UBM Controller 2Wire slave address */</span></div><div class="line">            .drive_connector_idx = 0x2U,                        <span class="comment">/* Indicates the DFC identity */</span></div><div class="line">            .drive_types_supported =                            <span class="comment">/* Indicates which drive types are supported in the DFC */</span></div><div class="line">            {</div><div class="line">                .sff_ta_1001 = <span class="keyword">true</span>,                            <span class="comment">/* SFF-TA-1001 PCIe */</span></div><div class="line">                .gen_z = <span class="keyword">false</span>,                                 <span class="comment">/* Gen-Z */</span></div><div class="line">                .sas_sata = <span class="keyword">true</span>,                               <span class="comment">/* SAS/SATA */</span></div><div class="line">                .quad_pcie = <span class="keyword">true</span>,                              <span class="comment">/* Quad PCIe */</span></div><div class="line">                .dfc_empty = <span class="keyword">true</span>,                              <span class="comment">/* DFC Empty */</span></div><div class="line">            },</div><div class="line">            .drive_link_width = <a class="code" href="group__group__ubm__enums.html#gga25b72ac193b03b7c8a3de9ed81668d21af40a4f7c8eb47f641e62d8d79e6124b2">MTB_UBM_LINK_WIDTH_X4</a>,          <span class="comment">/* Indicates the number of lanes in the port */</span></div><div class="line">            .port_type = <a class="code" href="group__group__ubm__enums.html#gga8523481e3974ed225ea2059ca5cce4a2a6b4e585160698893beaadfc55582446a">MTB_UBM_PORT_TYPE_SEGREGATED</a>,          <span class="comment">/* Indicates the connector port type which is routed from the DFC to the HFC */</span></div><div class="line">            .domain = <a class="code" href="group__group__ubm__enums.html#gga6c9a9506e1cbf8b17449a4f4bbdc1b8aa25db6cce4bc81d5427d4f95820516dbf">MTB_UBM_PORT_DOMAIN_PRIMARY</a>,              <span class="comment">/* Indicates if this route is describing the primary or secondary port of a DFC */</span></div><div class="line">            .max_sata_line_rate = <a class="code" href="group__group__ubm__enums.html#ggab1ec1458778a706bd254c5a718a13d28a9c26126bb4ce328dba127c0762f45c92">MTB_UBM_SATA_NO_RATE_LIMIT</a>,   <span class="comment">/* Max SATA Link Rate */</span></div><div class="line">            .max_pcie_line_rate = <a class="code" href="group__group__ubm__enums.html#ggad83b93024e86bfe947a1ddef18eb1f0fa6b3eaab5d64ccc50b221d228f88eef0f">MTB_UBM_PCIE_NO_RATE_LIMIT</a>,   <span class="comment">/* Max PCIe Link Rate */</span></div><div class="line">            .max_sas_line_rate = <a class="code" href="group__group__ubm__enums.html#gga7848037c7789e6e85875078254df1daaac0cf331675e14b6d4f86067a2e75b746">MTB_UBM_SAS_NO_RATE_LIMIT</a>,     <span class="comment">/* Max SAS Link Rate */</span></div><div class="line">            .hfc_starting_phy_lane = 0x0U,                      <span class="comment">/* Indicates the HFC starting lane */</span></div><div class="line">            .hfc_identifier = 0x2U,                             <span class="comment">/* Indicates the HFC identity */</span></div><div class="line">            .slot_offset = 0x02U,                               <span class="comment">/* Indicates the backplane slot offset for the DFC */</span></div><div class="line">        },</div><div class="line">        {</div><div class="line">            .ubm_ctrl_type = <a class="code" href="group__group__ubm__enums.html#gga0576582dae1a6af815a804705ab38ae3a3bfeff764d23f5a8619f0776a5d5afeb">MTB_UBM_CONTROLLER_SPEC_DEFINED</a>,   <span class="comment">/* UBM controller type */</span></div><div class="line">            .ubm_ctrl_slave_addr = 0x4DU,                       <span class="comment">/* UBM Controller 2Wire slave address */</span></div><div class="line">            .drive_connector_idx = 0x3U,                        <span class="comment">/* Indicates the DFC identity */</span></div><div class="line">            .drive_types_supported =                            <span class="comment">/* Indicates which drive types are supported in the DFC */</span></div><div class="line">            {</div><div class="line">                .sff_ta_1001 = <span class="keyword">true</span>,                            <span class="comment">/* SFF-TA-1001 PCIe */</span></div><div class="line">                .gen_z = <span class="keyword">false</span>,                                 <span class="comment">/* Gen-Z */</span></div><div class="line">                .sas_sata = <span class="keyword">true</span>,                               <span class="comment">/* SAS/SATA */</span></div><div class="line">                .quad_pcie = <span class="keyword">true</span>,                              <span class="comment">/* Quad PCIe */</span></div><div class="line">                .dfc_empty = <span class="keyword">true</span>,                              <span class="comment">/* DFC Empty */</span></div><div class="line">            },</div><div class="line">            .drive_link_width = <a class="code" href="group__group__ubm__enums.html#gga25b72ac193b03b7c8a3de9ed81668d21af40a4f7c8eb47f641e62d8d79e6124b2">MTB_UBM_LINK_WIDTH_X4</a>,          <span class="comment">/* Indicates the number of lanes in the port */</span></div><div class="line">            .port_type = <a class="code" href="group__group__ubm__enums.html#gga8523481e3974ed225ea2059ca5cce4a2a6b4e585160698893beaadfc55582446a">MTB_UBM_PORT_TYPE_SEGREGATED</a>,          <span class="comment">/* Indicates the connector port type which is routed from the DFC to the HFC */</span></div><div class="line">            .domain = <a class="code" href="group__group__ubm__enums.html#gga6c9a9506e1cbf8b17449a4f4bbdc1b8aa25db6cce4bc81d5427d4f95820516dbf">MTB_UBM_PORT_DOMAIN_PRIMARY</a>,              <span class="comment">/* Indicates if this route is describing the primary or secondary port of a DFC */</span></div><div class="line">            .max_sata_line_rate = <a class="code" href="group__group__ubm__enums.html#ggab1ec1458778a706bd254c5a718a13d28a9c26126bb4ce328dba127c0762f45c92">MTB_UBM_SATA_NO_RATE_LIMIT</a>,   <span class="comment">/* Max SATA Link Rate */</span></div><div class="line">            .max_pcie_line_rate = <a class="code" href="group__group__ubm__enums.html#ggad83b93024e86bfe947a1ddef18eb1f0fa6b3eaab5d64ccc50b221d228f88eef0f">MTB_UBM_PCIE_NO_RATE_LIMIT</a>,   <span class="comment">/* Max PCIe Link Rate */</span></div><div class="line">            .max_sas_line_rate = <a class="code" href="group__group__ubm__enums.html#gga7848037c7789e6e85875078254df1daaac0cf331675e14b6d4f86067a2e75b746">MTB_UBM_SAS_NO_RATE_LIMIT</a>,     <span class="comment">/* Max SAS Link Rate */</span></div><div class="line">            .hfc_starting_phy_lane = 0x0U,                      <span class="comment">/* Indicates the HFC starting lane */</span></div><div class="line">            .hfc_identifier = 0x3U,                             <span class="comment">/* Indicates the HFC identity */</span></div><div class="line">            .slot_offset = 0x03U,                               <span class="comment">/* Indicates the backplane slot offset for the DFC */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --> The first parameter requires configuring the Emulated EEPROM as a storage for FRU data. For more details, refer to the <a href="https://github.com/Infineon/emeeprom">Emulated EEPROM Middleware Library</a> documentation. An example of the configuration: <div class="fragment"><div class="line"><span class="comment">/* The size of data to store in EEPROM. Note the flash size used will be</span></div><div class="line"><span class="comment"> * the closest multiple of the flash row size */</span></div><div class="line"><span class="preprocessor">#define DATA_SIZE                       (256)</span></div><div class="line"></div><div class="line"><span class="comment">/* Simple Mode is turned on */</span></div><div class="line"><span class="preprocessor">#define SIMPLE_MODE                     (1U)</span></div><div class="line"></div><div class="line"><span class="comment">/* Increases the flash endurance by twice */</span></div><div class="line"><span class="preprocessor">#define WEAR_LEVELING                   (2U)</span></div><div class="line"></div><div class="line"><span class="comment">/* The Redundant Copy is turned off */</span></div><div class="line"><span class="preprocessor">#define REDUNDANT_COPY                  (0U)</span></div><div class="line"></div><div class="line"><span class="comment">/* The Blocking Write is turned on */</span></div><div class="line"><span class="preprocessor">#define BLOCKING_WRITE                  (1U)</span></div><div class="line"></div><div class="line">CY_ALIGN(CY_EM_EEPROM_FLASH_SIZEOF_ROW)</div><div class="line"><span class="keyword">const</span> uint8_t emEepromStorage[CY_EM_EEPROM_GET_PHYSICAL_SIZE(DATA_SIZE, SIMPLE_MODE, WEAR_LEVELING, REDUNDANT_COPY)] __attribute__((used, section(<span class="stringliteral">&quot;.cy_em_eeprom&quot;</span>))) = { 0U };</div><div class="line"></div><div class="line">cy_stc_eeprom_config_t eepromConfig =</div><div class="line">{</div><div class="line">    .eepromSize = DATA_SIZE,</div><div class="line">    .simpleMode = SIMPLE_MODE,</div><div class="line">    .wearLevelingFactor = WEAR_LEVELING,</div><div class="line">    .redundantCopy = REDUNDANT_COPY,</div><div class="line">    .blockingWrite = BLOCKING_WRITE,</div><div class="line">    .userFlashStartAddr = (uint32_t) &amp; (emEepromStorage[0U]),</div><div class="line">};</div></div><!-- fragment --> Then, set the the overview area parameters as desired. For the the parameters details, refer to the UBM Overview Area section in the <a href="https://members.snia.org/document/dl/27167">SFF-TA-1005</a> specification. An example of the configuration: <div class="fragment"><div class="line"><a class="code" href="group__group__ubm__fru__data__structures.html#structmtb__stc__ubm__fru__oa__config__t">mtb_stc_ubm_fru_oa_config_t</a> overview_area =</div><div class="line">{</div><div class="line">    .<a class="code" href="group__group__ubm__fru__data__structures.html#abd1bfe5c22ed1d00f4364fe5a3748570">two_wire_device_arrangement</a> = <a class="code" href="group__group__ubm__macros__fru__oa.html#ga574acb8b1ef0ee3e3de3a0e7eca857ff">MTB_UBM_FRU_OA_2WIRE_ARRANGEMENT_NO_MUX</a>, <span class="comment">/* Two-wire device arrangement. */</span></div><div class="line">    .two_wire_mux_address = 0x00U,                                          <span class="comment">/* Two-wire mux adress. */</span></div><div class="line">    .two_wire_max_byte_count = <a class="code" href="group__group__ubm__macros__fru__oa.html#ga7c274d349bd809ee06d365986ee2b109">MTB_UBM_FRU_OA_2WIRE_MUX_BYTE_CNT_32BYTES</a>,   <span class="comment">/* Two-wire max byte count. */</span></div><div class="line">    .ubm_max_time_limit = 0x04U,                                            <span class="comment">/* Device max. time limit. */</span></div><div class="line">    .ubm_controller_features =</div><div class="line">    {</div><div class="line">        .read_checksum_creation = <span class="keyword">true</span>,                                     <span class="comment">/* Indicates whether to add the checksum to the read phase of the two wire transaction. */</span></div><div class="line">        .write_checksum_checking = <span class="keyword">true</span>,                                    <span class="comment">/* Indicates whether to verify the checksum on the write phase of the two wire transaction. */</span></div><div class="line">        .cprsnt_legacy_mode = <span class="keyword">false</span>,                                        <span class="comment">/* Indicates the behavior of the CPRSNT#/CHANGE_DETECT# signal. */</span></div><div class="line">        .pcie_reset_change_count_mask = <span class="keyword">false</span>,                              <span class="comment">/* Indicates if a change to the PCIe Reset field causes the Change Count field to increment. */</span></div><div class="line">        .drive_type_installed_change_count_mask = <span class="keyword">false</span>,                    <span class="comment">/* Indicates if a change to the Drive Type Installed field causes the Change Count field to increment. */</span></div><div class="line">        .operational_state_change_count_mask = <span class="keyword">false</span>,                       <span class="comment">/* Indicates if a change to the Operational State field causes the Change Count field to increment. */</span></div><div class="line">        .perst_management_override = 0x00U,                                 <span class="comment">/* Indicates the DFC PERST# behavior when a Drive has been installed. */</span></div><div class="line">        .smbus_reset_control = <span class="keyword">false</span>                                        <span class="comment">/* Controls the DFC SMBRST# signal for all DFCs associated under the HFC. */</span></div><div class="line">    },</div><div class="line">    .maximum_power_per_dfc = 0x00U,                                         <span class="comment">/* Maximum power per DFC. */</span></div><div class="line">    .mux_channel_count = <a class="code" href="group__group__ubm__macros__fru__oa.html#gae0a95ca55238687dbd23e9821b87cf63">MTB_UBM_FRU_OA_2W_MUX_NO_MUX</a>,                      <span class="comment">/* Mux channel type. */</span></div><div class="line">    .enable_bit_location = <a class="code" href="group__group__ubm__macros__fru__oa.html#ga14fc990289da3748d088dc702e139e35">MTB_UBM_FRU_OA_2W_MUX_ENABLE_3CH_SEL</a>,            <span class="comment">/* Enable bit location. */</span></div><div class="line">    .mux_type = <a class="code" href="group__group__ubm__macros__fru__oa.html#gab97a6eba386e59eaaa47224c75d80f49">MTB_UBM_FRU_OA_2W_MUX_CH_ENABLE_LOC_CB</a>,                     <span class="comment">/* Mux type. */</span></div><div class="line">};</div></div><!-- fragment --> For the explanation of the Silicon Identity, Backplane Info, and Capabilities parameters, refer to the corresponding section of the <a href="https://members.snia.org/document/dl/27167">SFF-TA-1005</a> specification.</li>
<li>The second parameter <a class="el" href="structmtb__stc__ubm__backplane__control__signals__t.html" title="Backplane control signals configuration structure. ">mtb_stc_ubm_backplane_control_signals_t</a> contains the GPIO definition for HFC and DFC IO signals. The number of elements of this configurational array must match the number of HFCs and the number of DFCs configured. These signal definitions are a combination of <a href="https://members.snia.org/document/dl/27167">SFF-TA-1005</a>, <a href="https://members.snia.org/document/dl/26489">SFF-8639</a>, <a href="https://members.snia.org/document/dl/26900">SFF-TA-1001</a>, <a href="https://members.snia.org/document/dl/26837">SFF-TA-1009</a>, <a href="https://webstore.ansi.org/standards/incits/ansiincits3762003">SAS</a> and <a href="https://sata-io.org/">SATA</a> standards. Change the pin settings to match your specification. An example of the configuration: <div class="fragment"><div class="line"><a class="code" href="structmtb__stc__ubm__backplane__control__signals__t.html">mtb_stc_ubm_backplane_control_signals_t</a> ubm_backplane_control_signals =</div><div class="line">{</div><div class="line">    .<a class="code" href="structmtb__stc__ubm__backplane__control__signals__t.html#a59b3400b8130e22c02360c734f7ac707">dfc_io</a> =</div><div class="line">    {</div><div class="line">        {.<a class="code" href="group__group__ubm__io__signals.html#a49e145b3ac37768f2d017e7598942738">ifdet</a> = P0_2, .ifdet2 = P0_3, .prsnt = P1_2, .persta = P2_7, .perstb = P6_2, .pwrdis = P6_3, .refclken = P6_5, .dualporten = P8_0 },</div><div class="line">        {.ifdet = P12_7, .ifdet2 = P13_4, .prsnt = P13_5, .persta = P2_0, .perstb = P2_1, .pwrdis = P2_2, .refclken = P2_4, .dualporten = P2_5 },</div><div class="line">    },</div><div class="line"></div><div class="line">    .hfc_io =</div><div class="line">    {</div><div class="line">        {.sda = P9_1, .scl = P9_0, .i2c_reset = P3_0, .change_detect = P3_1, .bp_type = P3_2, .perst = P3_3 },</div><div class="line">        {.sda = P10_1, .scl = P10_0, .i2c_reset = P3_4, .change_detect = P3_5, .bp_type = P4_0, .perst = P4_1 },</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --> <dl class="section warning"><dt>Warning</dt><dd>Do not use the selected IO pins elsewhere in the application. Verify that the selected IO pins are not used in the ModusToolbox&trade; Device Configurator. </dd>
<dd>
The <a class="el" href="group__group__ubm__functions.html#ga8f6b9404cb8cc59d8479c976df0aa4c4" title="Initializes the UBM middleware. ">mtb_ubm_init()</a> function can detect if the IO pin was already initialized with the HAL function cyhal_gpio_init() and returned the appropriate return code, but it cannot detect if the IO pin was initialized by the Peripheral Driver Library directly.</dd></dl>
</li>
<li>The third parameter <a class="el" href="structmtb__stc__ubm__context__t.html" title="UBM context structure All fields for the context structure are internal. ">mtb_stc_ubm_context_t</a> contains internal middleware data structures and will not be changed by the application. <dl class="section note"><dt>Note</dt><dd>Keep the context variable accessible during the whole application execution time.</dd></dl>
</li>
<li>Your application configuration is complete for building and programmed using the ModusToolbox&trade; software. For the error codes returned by the <a class="el" href="group__group__ubm__functions.html#ga8f6b9404cb8cc59d8479c976df0aa4c4" title="Initializes the UBM middleware. ">mtb_ubm_init()</a> function, refer to <a class="el" href="group__group__ubm__enums.html#ga7edd9650e9144861643adbf7aefbcc48">mtb_en_ubm_status_t</a>.</li>
</ol>
<h2><a class="anchor" id="subsection_led_indication"></a>
LED indication</h2>
<p>The current implementation of the UBM Middleware does not include the LED blinking algorithm but assumes it is implemented by the application itself.</p>
<p>The DFC Status and Control Descriptor command contains the SES Array Device Slot Element, which can be used as an input to an LED blinking algorithm. So, the UBM Middleware has an optional functionality to notify the application when a valid SES Array Device Slot Control Element was received.</p>
<p>To enable this feature:</p><ol type="1">
<li>Set the related macro in <em>mtb_ubm_config.h:</em> <div class="fragment"><div class="line"><span class="preprocessor">#define MTB_UBM_SES_CB_ACTIVE           (1)</span></div></div><!-- fragment --></li>
<li>Declare the application handler of the <a class="el" href="group__group__ubm__ifc__callback__type.html#gaa1a7e8e35d1a414fb4e43448f8daeb51">mtb_ubm_ses_app_cb_t</a> type in your application: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> ubm_app_handler(<a class="code" href="group__group__ubm__ifc__data__structures.html#structmtb__stc__ubm__ses__app__cb__context__t">mtb_stc_ubm_ses_app_cb_context_t</a>* args);</div></div><!-- fragment --></li>
<li>Configure the application handler in the <a class="el" href="structmtb__stc__ubm__backplane__cfg__t.html" title="UBM backplane configuration structure. ">mtb_stc_ubm_backplane_cfg_t</a> configurational structure: <div class="fragment"><div class="line">ubm_backplane_configuration.ses_event_handler = ubm_app_handler;</div></div><!-- fragment --></li>
</ol>
<p>Now, the configured handler function will be called every time a valid SES Array Device Slot Control Element is received. The handler argument <a class="el" href="group__group__ubm__ifc__data__structures.html#structmtb__stc__ubm__ses__app__cb__context__t">mtb_stc_ubm_ses_app_cb_context_t</a> contains:</p><ul>
<li>The DFC index of the DFC Status and Control Descriptor command,</li>
<li>The pointer to the received SES Array Device Slot Control Element,</li>
<li>The pointer to the SES Array Device Slot Status Element.</li>
</ul>
<p>If the application needs/updates the SES Array Device Slot Status Element for the following read back, the handler function will return <em>true</em>. The SES Array Device Slot Status is ignored and not saved if the handler function returns <em>false</em>.</p>
<p>For the implementation example of the applicaion handler, refer to a corresponding code example.</p>
<h1><a class="anchor" id="section_ubm_commands"></a>
UBM Controller Commands</h1>
<p>Each of added to the configuration Controllers supports the following commands: </p><a class="anchor" id="multi_row"></a>
<table class="doxtable">
<caption>UBM Controller Commands</caption>
<tr>
<th>Command code </th><th>Read/Write </th><th>Command name </th><th>Description </th></tr>
<tr>
<td colspan="4" align="center">Generic commands </td></tr>
<tr>
<td align="center">00h </td><td>Read only </td><td>Operational State </td><td>Returns the operating state of the UBM Controller. </td></tr>
<tr>
<td align="center">01h </td><td>Read only </td><td>Last Command Status </td><td>Returns the last command execution status of the UBM Controller. </td></tr>
<tr>
<td align="center">02h </td><td>Read only </td><td>Silicon Identity and Version </td><td>Returns UBM Controller identification data. </td></tr>
<tr>
<td align="center">03h </td><td>Read only </td><td>Programming Update Mode Capabilities </td><td>Returns the Programming Update Mode capabilities of the UBM Controller. </td></tr>
<tr>
<td colspan="4" align="center">Programmable Update Mode Commands </td></tr>
<tr>
<td align="center">20h </td><td>Read/Write </td><td>Enter Programmable Update Mode </td><td>Indicates the sequence to unlock and transfer to Programmable Update Mode. </td></tr>
<tr>
<td align="center">21h </td><td>Read/Write </td><td>Programmable Mode Data Transfer </td><td>Indicates the method to exchange multiple bytes of the command, status, and data. </td></tr>
<tr>
<td align="center">22h </td><td>Read/Write </td><td>Exit Programmable Update Mode </td><td>Indicates to transfer out of Programmable Update Mode. </td></tr>
<tr>
<td colspan="4" align="center">Backplane Management Commands </td></tr>
<tr>
<td align="center">30h </td><td>Read only </td><td>Host Facing Connector Info </td><td>Returns the Host Facing Connector information. </td></tr>
<tr>
<td align="center">31h </td><td>Read only </td><td>Backplane Info </td><td>Returns the backplane number and type, which are unique in the chassis. </td></tr>
<tr>
<td align="center">32h </td><td>Read only </td><td>Starting Slot </td><td>Returns the Starting Slot, which is applied to the Slot Offset found in the UBM Port Route Information of the UBM FRU. </td></tr>
<tr>
<td align="center">33h </td><td>Read only </td><td>Capabilities </td><td>Returns the backplane capabilities. </td></tr>
<tr>
<td align="center">34h </td><td>Read only </td><td>Features </td><td>Returns the backplane features. </td></tr>
<tr>
<td align="center">35h </td><td>Read/Write </td><td>Change Count </td><td>The counter used to manage UBM Controller interrupts. </td></tr>
<tr>
<td align="center">36h </td><td>Read/Write </td><td>DFC Status and Control Descriptor Index </td><td>Controls the DFC Status and Control Descriptor to access. </td></tr>
<tr>
<td align="center">40h </td><td>Read/Write </td><td>DFC Status and Control Descriptor </td><td>Indicates the DFC Status and Control Descriptor data for the current DFC Status and Control Descriptor Index. </td></tr>
</table>
<p>All commands implemented per <a href="https://members.snia.org/document/dl/27167">SFF-TA-1005 Rev 1.4</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>UBM Middleware</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
